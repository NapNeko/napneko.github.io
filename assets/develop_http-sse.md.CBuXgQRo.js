import{_ as n,C as a,o as l,c as i,j as t,a as d,E as o,ar as h}from"./chunks/framework.BMjlEU-k.js";const u=JSON.parse('{"title":"HTTP-SSE","description":"","frontmatter":{},"headers":[],"relativePath":"develop/http-sse.md","filePath":"develop/http-sse.md","lastUpdated":1750596199000}'),p={name:"develop/http-sse.md"};function c(T,e,P,_,S,m){const r=a("NolebasePageProperties"),s=a("NolebaseGitChangelog");return l(),i("div",null,[e[0]||(e[0]=t("h1",{id:"http-sse",tabindex:"-1"},[d("HTTP-SSE "),t("a",{class:"header-anchor",href:"#http-sse","aria-label":'Permalink to "HTTP-SSE"'},"​")],-1)),o(r),e[1]||(e[1]=h('<h2 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h2><p>HTTP Server-Sent Events (SSE) 是一种服务器推送技术，允许服务器通过 HTTP 持久连接向客户端发送实时更新。相比于传统的轮询方式，SSE 更加高效，减少了服务器的压力。</p><h2 id="扩展原因" tabindex="-1">扩展原因 <a class="header-anchor" href="#扩展原因" aria-label="Permalink to &quot;扩展原因&quot;">​</a></h2><p>基于轮询或双 CS 的 HTTP Bot 框架需要双方配置两次 C/S 或者造成服务器压力。</p><h2 id="模型架构" tabindex="-1">模型架构 <a class="header-anchor" href="#模型架构" aria-label="Permalink to &quot;模型架构&quot;">​</a></h2><ul><li><strong>事件通知</strong>: 通过 HTTP-SSE 通知获取。</li><li><strong>API 操作</strong>: 通过 HTTP-GET 和 HTTP-POST 请求操作。</li></ul><p>至此完成双向主动通讯。该方式协议端完全作为 Server，应用端完全作为 Client，复用 HTTP 路径，同时规避轮询。</p><h2 id="如何启用" tabindex="-1">如何启用 <a class="header-anchor" href="#如何启用" aria-label="Permalink to &quot;如何启用&quot;">​</a></h2><p>在 WebUI 中启用 重启后重新查看配置，可以设置更多内容。</p><h2 id="事件接口" tabindex="-1">事件接口 <a class="header-anchor" href="#事件接口" aria-label="Permalink to &quot;事件接口&quot;">​</a></h2><p>要订阅事件，请访问 <code>/_events</code> 端点。</p><h2 id="常规接口" tabindex="-1">常规接口 <a class="header-anchor" href="#常规接口" aria-label="Permalink to &quot;常规接口&quot;">​</a></h2><p>例如 <code>/send_msg</code> 端点直接请求即可。</p>',13)),o(s)])}const f=n(p,[["render",c]]);export{u as __pageData,f as default};
