import{_ as l,C as i,o as p,c as h,j as a,a as k,E as e,aD as d}from"./chunks/framework.BeKdlGsR.js";const F=JSON.parse('{"title":"项目结构与最佳实践","description":"","frontmatter":{},"headers":[],"relativePath":"develop/plugin/structure.md","filePath":"develop/plugin/structure.md","lastUpdated":1770492615000}'),r={name:"develop/plugin/structure.md"};function o(c,s,g,E,u,y){const n=i("NolebasePageProperties"),t=i("NolebaseGitChangelog");return p(),h("div",null,[s[0]||(s[0]=a("h1",{id:"项目结构与最佳实践",tabindex:"-1"},[k("项目结构与最佳实践 "),a("a",{class:"header-anchor",href:"#项目结构与最佳实践","aria-label":'Permalink to "项目结构与最佳实践"'},"​")],-1)),e(n),s[1]||(s[1]=d(`<p>NapCat 插件模板（<code>napcat-plugin-template</code>）提供了一套经过生产验证的项目结构。理解该结构有助于编写更易维护和扩展的插件。</p><h2 id="目录结构详解" tabindex="-1">目录结构详解 <a class="header-anchor" href="#目录结构详解" aria-label="Permalink to &quot;目录结构详解&quot;">​</a></h2><p>以下是一个标准的插件项目的目录树：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span>src/</span></span>
<span class="line"><span>├── index.ts              # [入口] 插件的主入口文件</span></span>
<span class="line"><span>├── config.ts             # [配置] 定义插件配置结构及默认值</span></span>
<span class="line"><span>├── types.ts              # [类型] 定义插件内部使用的 TypeScript 类型</span></span>
<span class="line"><span>├── core/</span></span>
<span class="line"><span>│   └── state.ts          # [状态] 全局状态管理单例</span></span>
<span class="line"><span>├── handlers/             # [逻辑] 具体的业务逻辑处理</span></span>
<span class="line"><span>│   └── message-handler.ts</span></span>
<span class="line"><span>├── services/             # [服务] 外部服务接口或复杂功能封装</span></span>
<span class="line"><span>│   └── api-service.ts</span></span>
<span class="line"><span>└── webui/                # [前端] 插件的 WebUI 界面代码</span></span></code></pre></div><h3 id="_1-index-ts-插件入口" tabindex="-1">1. <code>index.ts</code> - 插件入口 <a class="header-anchor" href="#_1-index-ts-插件入口" aria-label="Permalink to &quot;1. \`index.ts\` - 插件入口&quot;">​</a></h3><p>这是插件被 NapCat 加载的地方。它的主要职责是：</p><ul><li>导出插件的生命周期函数（实现 <code>PluginModule</code> 接口）。</li><li>在 <code>plugin_init</code> 中初始化全局状态、注册路由等。</li><li>在 <code>plugin_onmessage</code> 中处理消息。</li><li>在 <code>plugin_cleanup</code> 中清理资源。</li></ul><p><strong>最佳实践</strong>：不要在 <code>index.ts</code> 中编写具体的业务逻辑。应该将逻辑委托给 <code>handlers/</code> 中的函数。</p><h3 id="_2-core-state-ts-全局状态管理" tabindex="-1">2. <code>core/state.ts</code> - 全局状态管理 <a class="header-anchor" href="#_2-core-state-ts-全局状态管理" aria-label="Permalink to &quot;2. \`core/state.ts\` - 全局状态管理&quot;">​</a></h3><p>插件通常需要维护一些全局状态，例如：</p><ul><li>NapCat 的上下文对象 (<code>NapCatPluginContext</code>)</li><li>当前的配置信息 (<code>config</code>)</li><li>插件的元数据（名称、路径等）</li></ul><p>模板中使用了一个单例模式的 <code>PluginState</code> 类来管理这些信息。这种方式允许在项目的任意位置（包括深层嵌套的函数中）直接访问 <code>ctx</code> 或 <code>config</code>，无需逐层传递参数。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { pluginState } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;../core/state&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 直接获取 logger</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pluginState.logger.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Doing something...&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 直接获取配置</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (pluginState.config.enableFeatureA) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_3-handlers-业务逻辑" tabindex="-1">3. <code>handlers/</code> - 业务逻辑 <a class="header-anchor" href="#_3-handlers-业务逻辑" aria-label="Permalink to &quot;3. \`handlers/\` - 业务逻辑&quot;">​</a></h3><p>这里存放具体的事件处理函数。</p><ul><li><code>message-handler.ts</code>: 处理群消息、私聊消息。</li><li><code>request-handler.ts</code>: 处理加群请求、好友请求。</li><li><code>notice-handler.ts</code>: 处理群通知（如成员变动）。</li></ul><p>建议将不同类型的逻辑拆分到不同的文件中。</p><h3 id="_4-services-服务层" tabindex="-1">4. <code>services/</code> - 服务层 <a class="header-anchor" href="#_4-services-服务层" aria-label="Permalink to &quot;4. \`services/\` - 服务层&quot;">​</a></h3><p>如果你的插件需要调用外部 API（如查询天气、获取游戏数据），或者包含复杂的独立功能模块（如定时任务管理器），建议放在 <code>services/</code> 目录下。</p><h3 id="_5-webui-前端界面" tabindex="-1">5. <code>webui/</code> - 前端界面 <a class="header-anchor" href="#_5-webui-前端界面" aria-label="Permalink to &quot;5. \`webui/\` - 前端界面&quot;">​</a></h3><p>NapCat 插件支持通过 WebUI 提供图形化配置或展示界面。模板中预置了基于 React + Vite 的前端项目结构。</p><ul><li>构建脚本会自动将 <code>webui/</code> 下的代码打包，并嵌入到插件发布包中。</li><li>在 <code>plugin_init</code> 中通过 <code>ctx.router.static</code> 将 WebUI 静态资源暴露给用户访问。</li></ul><h2 id="常用开发模式" tabindex="-1">常用开发模式 <a class="header-anchor" href="#常用开发模式" aria-label="Permalink to &quot;常用开发模式&quot;">​</a></h2><h3 id="依赖注入-vs-全局单例" tabindex="-1">依赖注入 vs 全局单例 <a class="header-anchor" href="#依赖注入-vs-全局单例" aria-label="Permalink to &quot;依赖注入 vs 全局单例&quot;">​</a></h3><p>虽然依赖注入（Dependency Injection）在大型应用中很常见，但在插件开发中，使用 <strong>全局单例</strong> (<code>pluginState</code>) 通常更简洁高效。它避免了在每个函数调用中透传 <code>ctx</code> 对象。</p><h3 id="错误处理" tabindex="-1">错误处理 <a class="header-anchor" href="#错误处理" aria-label="Permalink to &quot;错误处理&quot;">​</a></h3><p>在 <code>handlers</code> 中捕获错误非常重要，防止一个未捕获的异常导致整个插件甚至 Bot 崩溃。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 你的逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pluginState.logger.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;处理消息时发生错误&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, e);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="配置热重载" tabindex="-1">配置热重载 <a class="header-anchor" href="#配置热重载" aria-label="Permalink to &quot;配置热重载&quot;">​</a></h3><p>NapCat 支持配置的热重载。当用户在 WebUI 中修改配置后，插件可以通过 <code>plugin_on_config_change</code> 钩子感知变化：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { PluginModule } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;napcat-types&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> plugin_on_config_change</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PluginModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;plugin_on_config_change&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">_ctx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ui</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">_currentConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    _ctx.logger.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`配置项 \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">key</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} 已变更为:\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, value);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 根据变更更新内存中的状态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>或者通过 <code>plugin_config_controller</code> 获得更完整的 UI 控制能力。</p>`,32)),e(t)])}const _=l(r,[["render",o]]);export{F as __pageData,_ as default};
