import{_ as p,C as e,c as i,o as s,j as l,G as t,ar as n,a as c}from"./chunks/framework.DwOsETNj.js";const d="/assets/recall/1.png",h="/assets/recall/2.png",m="/assets/recall/3.png",_="/assets/recall/4.png",u="/assets/recall/5.png",N=JSON.parse('{"title":"防撤回寻找与思考✨","description":"","frontmatter":{},"headers":[],"relativePath":"other/ntrecall.md","filePath":"other/ntrecall.md","lastUpdated":1750596199000}'),b={name:"other/ntrecall.md"};function g(q,a,P,f,k,x){const r=e("NolebasePageProperties"),o=e("NolebaseGitChangelog");return s(),i("div",null,[a[0]||(a[0]=l("h1",{id:"防撤回寻找与思考✨",tabindex:"-1"},[c("防撤回寻找与思考✨ "),l("a",{class:"header-anchor",href:"#防撤回寻找与思考✨","aria-label":'Permalink to "防撤回寻找与思考✨"'},"​")],-1)),t(r),a[1]||(a[1]=n('<h2 id="准备步-本次环境-🔍" tabindex="-1">准备步 本次环境 🔍 <a class="header-anchor" href="#准备步-本次环境-🔍" aria-label="Permalink to &quot;准备步 本次环境 🔍&quot;">​</a></h2><p>工具 x64dbg ida</p><p>版本 NTQQ 34740</p><h2 id="第一步-找找线索🔍" tabindex="-1">第一步 找找线索🔍 <a class="header-anchor" href="#第一步-找找线索🔍" aria-label="Permalink to &quot;第一步 找找线索🔍&quot;">​</a></h2><p>打开 IDA Pro 把 wrapper.node 丢进去，先去吃个饭吧，饿死了</p><p>回来后打开 string view 看看</p><p>根据经验，撤回的英文嘛，要么是 recall 要么是 revoke 呢。</p><p>字符串里有 &quot;do&quot; 之类的不是下发通知，是客户端主动发送撤回请求哦。</p><p>其中相关的包括上面的 trpc 什么什么的（了解协议的小伙伴应该知道）</p><p><img src="'+d+'" alt="recall"></p><p>&quot;on grp recall&quot; 和 &quot;on c2c recall&quot;，这个看起来超级可疑的</p><h2 id="第二步-验证思路💭" tabindex="-1">第二步 验证思路💭 <a class="header-anchor" href="#第二步-验证思路💭" aria-label="Permalink to &quot;第二步 验证思路💭&quot;">​</a></h2><p>于是呢，我们找到 xref &quot;on grp recall&quot;，跳到目标函数 <img src="'+h+'" alt="recall"></p><p>然后对这部分打个断点，发现撤回的时候果然触发了这部分代码!</p><p><img src="'+m+'" alt="recall"></p><p>所以确定啦，这就是撤回处理部分</p><h2 id="第三步-破坏逻辑🔨" tabindex="-1">第三步 破坏逻辑🔨 <a class="header-anchor" href="#第三步-破坏逻辑🔨" aria-label="Permalink to &quot;第三步 破坏逻辑🔨&quot;">​</a></h2><p>猜测NTQQ撤回逻辑很简单嘛，肯定包括删除数据库、中断图片文件请求、回收一切相关的东西呀。</p><p>为了阻止这些事情发生，我们要让 recall 逻辑走错路线，比如让它判断不出这是 recall，或者给它填充错误的内存数据。</p><p><img src="'+_+'" alt="recall"> 我选了两处地方，第一处把 jnbe 改成 jbe（我实验的这个），第二处也是同理，任意反转一处逻辑应该就行了。</p><p><img src="'+u+'" alt="recall"> 直接右键汇编 让逻辑反过来，同时保持字节数一致，这样就完成反撤回消息 此时可进行测试</p><h2 id="思考之后🤔" tabindex="-1">思考之后🤔 <a class="header-anchor" href="#思考之后🤔" aria-label="Permalink to &quot;思考之后🤔&quot;">​</a></h2><p>但是有个问题，如果这样破坏了 recall 逻辑，我怎么知道谁撤回了消息呀？我也想区分哪条撤回了</p><p>这里有两个方案可以选择呢：</p><ol><li><p>手动解协议方案（js/native hook隔离逻辑）💟</p><p>根据经验，撤回的 sysmsg 可以通过 ipc 拿到协议包，或者像 napcat 一样注册 listener 直接获取 sysmsg 协议包。</p><p>解完协议后，可以调用 QQ 自己的 API 去获取撤回消息（因为我们阻止了删除数据库）。</p><p>如果想要通知，可以调用 msgService 的 addLocalGrayTip 添加小灰条提示</p><p>当然也可以对前端随便加，爱怎么改就怎么改</p></li><li><p>node native 模块方案（js/native hook 需要通讯）💕</p><p>可以写成 node native 模块，提取撤回的结构体数据。</p><p>启动时注册一个js callback，撤回时 native 调用 callback 就能拿到相关结构</p><p>然后就和上面一样了</p></li><li><p>动态模块 /patch 方案（仅 native hook）💝</p><p>写成这个后如果需要通知用户消息哪条撤回了</p><p>需要从外部获取 msgService（通过 napi 操作和 Hook 操作）。</p><p>获取到 msgService 后直接调用它的 addLocalGrayTip，就可以添加小灰条通知,当然你也可以不提示用户哪条消息撤回了这样就不用写了这个了。</p></li></ol><h2 id="优势总结✅" tabindex="-1">优势总结✅ <a class="header-anchor" href="#优势总结✅" aria-label="Permalink to &quot;优势总结✅&quot;">​</a></h2><ol><li>无需缓存消息，所有数据均保存在 NTQQ 数据库中</li><li>图片资源下载不受影响，可随时获取</li><li>实现更加优雅</li></ol><h2 id="潜在问题⚠️" tabindex="-1">潜在问题⚠️ <a class="header-anchor" href="#潜在问题⚠️" aria-label="Permalink to &quot;潜在问题⚠️&quot;">​</a></h2><ol><li>跨平台兼容性较差，需针对不同系统分别适配</li><li>直接修改程序执行流程可能导致稳定性问题</li><li>版本更新后需重新分析适配</li></ol><h2 id="总结文章🤔" tabindex="-1">总结文章🤔 <a class="header-anchor" href="#总结文章🤔" aria-label="Permalink to &quot;总结文章🤔&quot;">​</a></h2><p>但是相比于现在LL社区方案是更有效率的 不会打断文件/图片下载</p><p>同时没有消息缓存的概念 多久的消息都不影响</p>',32)),t(o)])}const T=p(b,[["render",g]]);export{N as __pageData,T as default};
