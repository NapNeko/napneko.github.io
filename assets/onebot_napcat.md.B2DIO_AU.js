import{_ as s,C as e,c as n,o as c,j as t,G as o,ar as l,a as i}from"./chunks/framework.DwOsETNj.js";const u=JSON.parse('{"title":"NapCat 资源与消息 ID 设计说明","description":"","frontmatter":{},"headers":[],"relativePath":"onebot/napcat.md","filePath":"onebot/napcat.md","lastUpdated":1745553435000}'),d={name:"onebot/napcat.md"};function b(g,a,N,_,m,h){const r=e("NolebasePageProperties"),p=e("NolebaseGitChangelog");return c(),n("div",null,[a[0]||(a[0]=t("h1",{id:"napcat-资源与消息-id-设计说明",tabindex:"-1"},[i("NapCat 资源与消息 ID 设计说明 "),t("a",{class:"header-anchor",href:"#napcat-资源与消息-id-设计说明","aria-label":'Permalink to "NapCat 资源与消息 ID 设计说明"'},"​")],-1)),o(r),a[1]||(a[1]=l('<p>NapCat 由于无数据库设计，采用了 LRU（最近最少使用）缓存机制来管理消息和文件资源。消息的 ID 并非连续数字，而是基于哈希算法生成的完全正整数。每条消息的 ID 都是唯一的，且在大约 5000 条消息后会因 LRU 策略而过期并被清理。文件（file）标识的生成同样受 LRU 缓存机制管理。</p><blockquote><p>⚠️ 由于 NapCat 不存储历史数据，<strong>已撤回的消息无法被再次获取或恢复</strong>，请注意消息的时效性。</p></blockquote><h2 id="napcat-资源-url-参数类型" tabindex="-1">NapCat 资源 URL 参数类型 <a class="header-anchor" href="#napcat-资源-url-参数类型" aria-label="Permalink to &quot;NapCat 资源 URL 参数类型&quot;">​</a></h2><p>NapCat 支持多种资源 URL 规范，便于灵活引用和传递文件资源。主要支持以下几种格式：</p><ul><li><p><strong>base64</strong> 以 <code>base64://</code> 协议开头，内容为 base64 编码的文件数据。<br> 例如：<br><code>base64://iVBORw0KGgoAAAANSUhEUgAA...</code></p></li><li><p><strong>path</strong><br> 本地文件路径，适用于本地资源访问。<br> 例如：<br><code>C:/Users/xxx/Pictures/image.png</code></p></li><li><p><strong>fileurl</strong><br> NapCat 规范的文件 URL，通常用于内部文件标识。<br> 例如：<br><code>file://1234567890</code><br> 其中 <code>1234567890</code> 为 NapCat 生成的文件哈希 ID。</p></li><li><p><strong>http/https</strong><br> 标准的网络资源 URL。<br> 例如：<br><code>https://example.com/image.png</code></p></li><li><p><strong>dataurl-base64</strong><br> 以 <code>data:</code> 协议开头，内容为 base64 编码的文件数据。<br> 例如：<br><code>data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA...</code></p></li></ul><hr><p>通过上述设计，NapCat 能够高效地管理消息和文件资源，既保证了唯一性和安全性，又兼顾了资源的灵活访问与过期清理。</p>',7)),o(p)])}const A=s(d,[["render",b]]);export{u as __pageData,A as default};
